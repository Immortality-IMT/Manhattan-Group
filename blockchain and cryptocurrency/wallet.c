#include "functions.h"

/* 
- Wallet, generate keys, encode keys, store them in wallet.db
- Transactions, sender key, receiver key, amount, add to temp transactions.db
- Mine, transactions into blocks, add to blockchain.db
- Add block to blockchain, add to blockchain.db
- Various shas, verifications, proofs, preferences, standardized accorss the network

Compile with...
    gcc -g -o wallet transactions.c wallet.c verifications.c functions.h miner.c blockchain.c base58.c keccak.c -lssl -lcrypto -lsqlite3 -lz
*/

//Generate private key - using Elliptic Curve Cryptography (ECC), specifically secp256k1 curve
BIGNUM* private_key() {
    //Private key is always 256 bits = 32 bytes, unsigned char private_key[32];
    //Private key is encoded to hex to differentiate it from the address
    BIGNUM* private_key = BN_new();
    if (!BN_rand(private_key, 256, -1, 0)) {
        // handle error
    }
    return private_key;
}

//Generate public key, using private key - using Elliptic Curve Cryptography (ECC), specifically secp256k1 curve
unsigned char* public_key(BIGNUM* private_key) {
    //Public key is always 33 bytes, encoded to hex always 66 bytes
    EC_GROUP* ecgroup = EC_GROUP_new_by_curve_name(NID_secp256k1);
    EC_POINT* pub_key = EC_POINT_new(ecgroup);
    EC_POINT_mul(ecgroup, pub_key, private_key, NULL, NULL, NULL);

    unsigned char* pub_key_ptr;
    size_t len;
    do {
        len = EC_POINT_point2oct(ecgroup, pub_key, POINT_CONVERSION_COMPRESSED, NULL, 0, NULL);
        pub_key_ptr = (unsigned char*)malloc(len);
        EC_POINT_point2oct(ecgroup, pub_key, POINT_CONVERSION_COMPRESSED, pub_key_ptr, len, NULL);
        free(pub_key_ptr);
    } while (len != 33);

    EC_GROUP_free(ecgroup);
    EC_POINT_free(pub_key);
    return pub_key_ptr;
}

//address is generated by taking the Keccak-256 hash of the public key
void generate_new_address(const unsigned char *public_key, unsigned char *address) {

    int RIPEMD160_DIGEST_LEN = 20;
    int SHA256_DIGEST_LEN = 32;

/*
    RIPEMD160_DIGEST_LENGTH - 20 bytes
    SHA256_DIGEST_LENGTH - 32 bytes
    Address is 25 bytes (20 bytes for the RIPEMD160 hash of the public key concatenated with a 4-byte checksum).
    Public key is 33 bytes
    A base 58 encoded address size is a max of 35
*/

  // Hash the public key with Keccak-256
  unsigned char keccak_hash[32];
  shake256(keccak_hash, 32, public_key, 32);

  // Hash the Keccak-256 hash with RipeMD-160
  unsigned char ripemd_hash[RIPEMD160_DIGEST_LEN];
  RIPEMD160(keccak_hash, 32, ripemd_hash);

  // Add a version byte to the RipeMD-160 hash
  unsigned char version_hash[RIPEMD160_DIGEST_LEN + 1];
  version_hash[0] = 0x00;
  memcpy(version_hash + 1, ripemd_hash, RIPEMD160_DIGEST_LEN);

  // Hash the versioned hash twice with SHA-256
  unsigned char sha256_hash1[SHA256_DIGEST_LEN];
  SHA256(version_hash, RIPEMD160_DIGEST_LEN + 1, sha256_hash1);
  unsigned char sha256_hash2[SHA256_DIGEST_LEN];
  SHA256(sha256_hash1, SHA256_DIGEST_LEN, sha256_hash2);

  // Take the first 4 bytes of the second SHA-256 hash as the checksum
  unsigned char checksum[4];
  memcpy(checksum, sha256_hash2, 4);

  // Add the checksum to the end of the public key hash
  memcpy(address, version_hash, RIPEMD160_DIGEST_LEN + 1);
  memcpy(address + RIPEMD160_DIGEST_LEN + 1, checksum, 4);

  // Null-terminate the address
  address[RIPEMD160_DIGEST_LEN + 5] = '\0';
}

void private_key_to_hex(BIGNUM *private_key_ptr, char hex_private_key[66]) {
  char *temp = BN_bn2hex(private_key_ptr);
  strcpy(hex_private_key, temp);
  OPENSSL_free(temp);
}

void public_key_to_hex(unsigned char* public_key, char hex_public_key[66]) {
  int i;
  for (i = 0; i < 32; i++) {
    sprintf(hex_public_key + (i * 2), "%02X", public_key[i]);
  }
}

int generate_address() {

    sqlite3 *db;
    int rc;
    char *err_msg = 0;

    struct wallet new_wallet;
    /*
        new_wallet.public_key; //use address instead
        new_wallet.private_key; //secret key used to secure funds
        new_wallet.address; //what you send to get pay or to pay
        new_wallet.statement; //bank statement of past transactions
        new_wallet.balance; //how much money you have
    */

    rc = sqlite3_open(DB_WALLET, &db);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Cannot open database: %s\n", sqlite3_errmsg(db));
        sqlite3_close(db);
        return 1;
    }

    const char * create_wallet_table = "CREATE TABLE IF NOT EXISTS wallet (address TEXT PRIMARY KEY, private_key TEXT, public_key TEXT, statement TEXT, balance TEXT);";

    rc = sqlite3_exec(db, create_wallet_table, 0, 0, &err_msg);

    if (rc != SQLITE_OK ) {
        fprintf(stderr, "Failed to create table: %s\n", err_msg);
        sqlite3_free(err_msg);
        sqlite3_close(db);
        return 1;
    }

    char sql[1024];
    unsigned char raw_address[25]; //[RIPEMD160_DIGEST_LENGTH + 5];

            for (int i = 0; i < 5; i++) {

                memset(new_wallet.address, 0, sizeof(new_wallet.address));
                memset(new_wallet.public_key, 0, sizeof(new_wallet.public_key));
                memset(new_wallet.private_key, 0, sizeof(new_wallet.private_key));

                BIGNUM* private_key_ptr = private_key(); //generate private key
                unsigned char* public_key_ptr = public_key(private_key_ptr); //generate public key
                generate_new_address(public_key_ptr, raw_address); //generate address from public key

                //private and public key stored as hex, address as base58

                //Private key stored as hex, always 66 bytes
                private_key_to_hex(private_key_ptr, new_wallet.private_key);
                printf("Hex encoded privat key: %s\n", new_wallet.private_key);

                //Public key stored as hex, always 66 bytes
                public_key_to_hex(public_key_ptr, new_wallet.public_key);
                printf("Hex encoded public key: %s\n", new_wallet.public_key);

                size_t out_len = sizeof(new_wallet.address);
                memset(new_wallet.address, 0, sizeof(25)); //address
                base58_encode(raw_address, 25, new_wallet.address, &out_len);
                printf("Base58 encoded address: %s\n", new_wallet.address);

                BN_free(private_key_ptr);

                //Insert the address into the database
                snprintf(sql, sizeof(sql), "INSERT INTO wallet (address, private_key, public_key, balance) VALUES ('%s','%s','%s','%s');", new_wallet.address, new_wallet.private_key, new_wallet.public_key, "0");
                rc = sqlite3_exec(db, sql, 0, 0, &err_msg);
                if (rc != SQLITE_OK ) {
                    fprintf(stderr, "Failed to insert address: %s\n", err_msg);
                    sqlite3_free(err_msg);
                }
            }

    printf("Successfully stored addresses in the wallet.\n");

    sqlite3_close(db);

}

void print_table(const char* db_name, const char* table_name) {
    sqlite3 *db;
    char *err_msg = 0;
    int rc = sqlite3_open(db_name, &db);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Cannot open database: %s\n", sqlite3_errmsg(db));
        sqlite3_close(db);
        return;
    }

    char sql[256];
    sprintf(sql, "SELECT * FROM %s", table_name);

    rc = sqlite3_exec(db, sql, callback, 0, &err_msg);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "SQL error: %s\n", err_msg);
        sqlite3_free(err_msg);
    }

    sqlite3_close(db);
}

/*
static int callback(void *data, int argc, char **argv, char **col_name) {
    for (int i = 0; i < argc; i++) {
        printf("%s = %s\n", col_name[i], argv[i] ? argv[i] : "NULL");
    }
    printf("\n");
    return 0;
}*/

static int callback(void *data, int argc, char **argv, char **col_name) {

/* To use huffman coding compress, to decompress before echo out
int decompressed_data_len = 0;

    for (int i = 0; i < argc; i++) {
        if (strcmp(col_name[i], "data") == 0) {

            char *decompressed_data = (char *) malloc(CHUNK);
            memset(decompressed_data, 0, CHUNK); //clear the mem so no jink chars are present

            int decompressed_data_len = 0;
            int ret = decompress_data(argv[i], strlen(argv[i]), &decompressed_data, &decompressed_data_len);
            if (ret != 0) {
                printf("Failed to decompress data\n");
                return 1;
            }

            printf("%s = %s\n", col_name[i], decompressed_data);
            free(decompressed_data);

        } else {
            printf("%s = %s\n", col_name[i], argv[i] ? argv[i] : "NULL");
        }
    }
*/

    for (int i = 0; i < argc; i++) {
        printf("%s = %s\n", col_name[i], argv[i] ? argv[i] : "NULL");
    }

    printf("\n");
    return 0;
}

int main() {

	int choice = 0, n = 0, whichIndex = 0;
	char sender, receiver;
	int inputnums = 0;
	float money = 0;

    while(1) {

    	printf("\nBlockchain demonstrator application <transaction account>\t\n");
    	printf("Please enter a number on your keypad\n");
    	printf("\n(1) Generate new addresses\n(2) Print all addresses\n(3) Make a transaction\n(4) Print out transaction pool\n(5) Mine transactions into a block\n(6) Print out blockchain\n(7) Verify transaction\n(8) Verify block\n(9) Verify blockchain\n(10) Exit\n");
        printf("Enter a choice: ");

    	scanf("%d",&choice);
    
    		switch(choice){

    			case 1:
    				printf("\nWallet: Generating 5 new address into wallets.db\n\n");
                    generate_address();
    				break;
    			case 2:
    				printf("\nWallet: Printing out wallet database (wallet.db)\n\n");
                    print_table(DB_WALLET, "wallet");
    				break;
                case 3:
    				printf("Transaction: Make a new transaction, enter address of both parties and the amount of money\n");
                    printf("e.g. A6i+1ZCmn0hTc5rwXTZtO3V7GqmQBnz8OA65JZ+zxoQ=, AzpGlJ0vRgNVpHc2vSJ14pWbnn02mc7Az3C88y74GTM=, 50)\n");
    				create_transaction();
    				break;
    			case 4:
    				printf("\nTransaction: Printing out transaction pool (transactions.db)\n\n");
                    print_table(DB_TRANSACTIONS, "transactions");
    				break;
    			case 5:
                    printf("Mining: Generate block (create_block)\n\n");
    				mine(); //TODO allow the miner to choose which transactions to mine 
       				break;
    			case 6:
    				printf("Print out blockchain:\n\n");
                    start_blockchain();
                    print_table(DB_BLOCKCHAIN, "blocks");
                	break;
    			case 7:
    				printf("Blockchain: Verify transaction:\n\n");//
    				verify_transaction();
    				break;
    			case 8:
    				printf("Blockchain: Verify block:\n\n");//
    				verify_block();
    				break;
    			case 9:
    				printf("Blockchain: Verify blockchain:\n\n");//
    				verify_chain();
    				break;
                case 10:
                    return 0;
                    break;
    			default:
    				printf("Only numbers between 1 and 10\n");
    				break;
    		    }
    	}

    return 0;
}

